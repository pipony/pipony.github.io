<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on </title>
    <link>https://huangxindi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://huangxindi.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mysql修改root密码</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/mysql%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/</link>
      <pubDate>Sun, 04 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/mysql%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81/</guid>
      <description>Mysql修改root密码 背景：linux系统，忘记mysql的root密码，该怎么修改root密码？
复制阿里云的在线服务中提出的解决方案👇。亲测ok
如果忘记了MySQL数据库root用户的密码，可以通过修改配置文件，登录时跳过密码，然后在数据库里面修改密码。一般数据库默认的用户为root。
执行如下命令，编辑MySQL数据库的my.cnf配置文件。
vim /etc/my.cnf 说明：my.cnf配置文件的路径以实际环境为准。
在[mysqld]字段下新增如下内容，然后保存退出。
skip-grant-tables 执行如下命令，重启MySQL服务。
/etc/init.d/mysqld restart 说明：MySQL启动脚本路径以实际环境为准。
执行如下命令，登录数据库。
/usr/bin/mysql 说明：MySQL命令路径以实际环境为准。
依次执行如下SQL语句，更新密码。
USE mysql;UPDATE user SET authentication_string = password (&amp;#39;[$Password]&amp;#39;) WHERE User = &amp;#39;root&amp;#39;;flush privileges;quit 说明：[$Password]为新密码，不建议新密码为“123456”，此密码太简单，密码需要满足密码复杂性要求，需要大小写字母和数字组合，最小长度为8位，根据此密码策略，设置密码。
再次编辑/etc/my.cnf配置文件，删除或者注释第2步添加的skip-grant-tables。 执行如下命令，重启MySQL服务。
/etc/init.d/mysqld restart 使用新密码登录数据库，确认能正常登录。
这里有个注意点：
user表中，可能有两个字段表示用户密码的（Password和authentication_string）。根据mysql的版本不同，可能用前者或是后者来存储登陆密码。比如我的mysql版本是：
mysql&amp;gt; select version(); +------------+ | version() | +------------+ | 5.6.50-log | +------------+ 1 row in set (0.00 sec) 最开始我是用上述解决方案中的语句设置authentication_string字段：
UPDATE user SET authentication_string = password (&amp;#39;[$Password]&amp;#39;) WHERE User = &amp;#39;root&amp;#39;; 发现设置完还是登陆不了。后面就试着把Password字段也设置下，才可以使用新密码登陆：</description>
    </item>
    
    <item>
      <title>oracle-&gt;mysql数据迁移数据事项</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/oracle-mysql%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Sun, 04 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/oracle-mysql%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E4%BA%8B%E9%A1%B9/</guid>
      <description>oracle-&amp;gt;mysql数据迁移数据事项 概述 从oracle数据迁移到mysql前，需要特别关注两者的区别，才能做好相应的转换及评估。
ORACLE&amp;amp;MYSQL主要差异 图片来源： https://www.infoq.cn/article/rc7urvfsmv94jcaw3z2a
MySQL 不支持的功能项 MySQL 没有并行的概念，不支持并行； MySQL 优化器较弱，复杂 SQL 建议拆分简单 SQL； MySQL 对于子查询优化不是很好； MySQL 不支持物化视图、存储过程改造、同义词改造、dblink 需要改造。 迁移原则 参考： https://www.infoq.cn/article/rc7urvfsmv94jcaw3z2a
迁移数据时，请遵循以下准则，其中大部分准则同时适用于一次性加载方法和实时复制方法：
字符集：确保源 Oracle 数据库与目标 MySQL 数据库之间的字符集兼容； 外键：要提升提取速度，请暂时停用目标 MySQL 数据库上的外键限制条件。加载完成后再启用外键限制条件； 索引：与外键类似，目标 MySQL 数据库上的索引可能会显著降低初始加载的速度。确保在初始加载完成之前，在目标数据库上未创建索引； Oracle 序列：MySQL 支持 AUTO_INCREMENT 而不是序列。确保在初始加载期间停用 AUTO_INCREMENT 特性，以避免覆盖 Oracle 的序列生成的值。在初始加载完成后，将 AUTO_INCREMENT 特性添加到主键列； 网络连接：如果您使用的是 GoldenGate TDM，请确保来源环境和目标环境都可以与 GoldenGate TDM 产品建立网络连接，以允许在 Oracle 端捕获数据并在 MySQL 端加载数据。 迁移难点 参考：
https://www.infoq.cn/article/rc7urvfsmv94jcaw3z2a
字符集 对于字符集，需要考虑的问题为迁移过程字段长度匹配情况，迁移后数据是否乱码，以及迁移后字符集转换后空间的问题。
字段长度匹配，空间估算 NULL和空串处理 使用文件导入到 MySQL 时字段中的空值 null 需要使用\N 表示，如果用空字符串表示，那么根据不同的数据类型，MySQL 处理也各异。</description>
    </item>
    
    <item>
      <title>Mysql导入导出</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/mysql%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/mysql%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</guid>
      <description>Mysql导入导出 导出 mysqldump (1) 导出完整数据：
mysqldump -u用户名 -p 数据库名 &amp;gt; 数据库名.sql
例如：# /usr/local/mysql/bin/mysqldump -uroot -p abc &amp;gt; abc.sql
(2) 只导出表结构（使用 -d 选项）：
mysqldump -u用户名 -p -d 数据库名 &amp;gt; 数据库名.sql
INTO OUTFILE https://www.modb.pro/db/98539
SELECT * FROM data_tbl --查找数据源，如果是全表所有字段也可以用 TABLE &amp;lt;talbe&amp;gt; INTO OUTFILE &amp;#34;/tmp/data.txt&amp;#34; --数据输出文件 FIELDS TERMINATED BY &amp;#39;,&amp;#39; --字段分隔符 OPTIONALLY ENCLOSED BY &amp;#39;&amp;#34;&amp;#39; --字段引用符 LINES TERMINATED BY &amp;#39;\n&amp;#39; --整条记录分割符 ; 导入 &amp;lt;.sql mysql -u用户名 -p 数据库名 &amp;lt; 数据库名.sql
例如：
# mysql -uroot -p123456 &amp;lt; abc.</description>
    </item>
    
    <item>
      <title>数据库分页查询</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 21 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</guid>
      <description>数据库分页查询 数据库分页语句使用limit语法来实现。除了基础的limit用法，还有一些优化的方法。
LIMIT基础用法 SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset
参数1表示偏移量，参数2表示返回记录行的最大数目。
需要注意：初始偏移量是0而不是1。
举例：
SELECT * FROM table LIMIT 5,10; # 检索记录行 6-15 SELECT * FROM table LIMIT 95,-1; # 检索记录行 96-last SELECT * FROM table LIMIT 5; # 检索前 5 个记录行 （LIMIT n 等价于 LIMIT 0,n） select * from table LIMIT 4 offset 9; # 返回从第9行开始的4条记录 （此时第1个参数表示最多返回几行记录，offset后面的第2个参数表示从第4行开始） # 返回第pageNum页,每页条数为numPerPage 条数据的sql语句写法为 select * from table limit (pageNum-1)*numPerPage ,numPerPage # 方法1 select * from table limit numPerPage offset (pageNum-1)*numPerPage # 方法2 优化分页查询方法 由于基础的分页查询方式会从数据库第一条记录开始扫描，所以当LIMIT的offset较大时，查询速度会越来越慢。下面列举一些优化的分页查询方法。</description>
    </item>
    
    <item>
      <title>数据库日志基础</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 21 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80/</guid>
      <description>数据库日志基础 世上无难事，只要有日志。
本文以Mysql为例，研究支持的日志。
数据库日志类型 记录方式分类：
逻辑日志：可以简单理解为记录的就是sql语句 。 物理日志：mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。 日志类型分类：
二进制日志（binlog） 错误日志 通用查询日志 慢查询日志 中继日志（relay-log） 数据定义语句日志 其中，后两种是Mysql 8 新增的日志。除二进制日志外，其他日志都是文本文件。
慢查询日志:记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。通用查询日志:记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。错误日志:记录MysQL服务的启动、运行或停止MysQL服务时出现的问题，方便我们了解服务器的状态，从对服务器进行维护。二进制日志:记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。中继日志:用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。数据定义语句日志:记录数据定义语句执行的元数据操作。来自：https://blog.csdn.net/xiaowanziddd/article/details/125963915 此外，还有文章（https://www.cnblogs.com/shengruxiahuaya/p/16602850.html）提到事务日志（重做日志redo log和回滚日志undo log）：
​	binlog日志和回滚日志undo log日志都属于逻辑日志，记录的是sql语句。而redo log 重做日志属于物理日志，记录的是数据页的变更。
默认日志文件名 如果不进行额外指定的话，mysql日志会有默认的存放路径和文件名。
默认存放路径：DATADIR（数据目录）
默认文件名：
二进制日志：hostname-bin.000001（编号依次增加） 错误日志：hostname.err 通用查询日志：hostname-general.log 慢查询日志：hostname.slow.log 中继日志：hostname-relay-bin.000001（编号依次增加） 数据定义语句日志 二进制日志（binlog） 记录所有的DDL语句和DML语句，但不包括查询语句。binlog 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。binlog 是通过追加的方式进行写入的，可以通过max_binlog_size 参数设置每个 binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。
使用场景：
- 主从复制：在 Master 端开启 binlog ，然后将 binlog发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。- 数据恢复：通过使用 mysqlbinlog 工具来恢复数据。 二进制日志格式：</description>
    </item>
    
    <item>
      <title>分区表</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/%E5%88%86%E5%8C%BA%E8%A1%A8/</link>
      <pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/%E5%88%86%E5%8C%BA%E8%A1%A8/</guid>
      <description>分区表 基本概念 分区、分表、分库、分片
参考链接：
https://blog.csdn.net/wqaiwsj/article/details/124684356
https://www.cnblogs.com/qianmojie/p/16326975.html
分区：将数据从物理上分成若干个小表存储，实际上还是一张表。为了在特定的SQL操作中减少数据读写的总量以缩减响应时间，提升查询效率。
分表：把一张表按一定的规则分解成N个具有独立存储空间的实体表。
分库：多表放在不同的服务器中，突破单节点数据库服务器的I/O能力限制。
分片：在分布式存储系统中，数据需要分散存储在多台设备上，数据分片（Sharding）就是用来确定数据在多台存储设备上分布的技术
常见分区类型 以mysql为例
range分区：给定连续区间 list分区：匹配一个离散值集合 hash分区：基于用户定义的表达式（MySQL 中有效的、产生非负整数值的任何表达式）的返回值来进行选择的分区 key分区：根据MySQL数据库提供的哈希函数来进行分区。 另外，还需要关注自动分区表（mysql不能自然支持，其他数据库可能支持，如gaussdb）
分区表定义 参考：https://www.cnblogs.com/dream98/p/10620877.html
RANGE分区 CREATE TABLE employees ( id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30), hired DATE NOT NULL DEFAULT &amp;#39;1970-01-01&amp;#39;, separated DATE NOT NULL DEFAULT &amp;#39;9999-12-31&amp;#39;, job_code INT NOT NULL, store_id INT NOT NULL ) partition BY RANGE (store_id) ( partition p0 VALUES LESS THAN (6), partition p1 VALUES LESS THAN (11), partition p2 VALUES LESS THAN (16), partition p3 VALUES LESS THAN (21) ); 如果增加了一个编号为第21的商店，将会发生什么呢？在这种方案下，由于没有规则把store_id大于20的商店包含在内，服务器将不知道把该行保存在何处，将会导致错误。 要避免这种错误，可以将最后一行规则换成：</description>
    </item>
    
    <item>
      <title>BenchmarkSQL性能测试</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/benchmarksql%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 15 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/benchmarksql%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description>BenchmarkSQL性能测试 何为BenchmarkSQL BenchmarkSQL是一款经典的开源数据库测试工具，其包含 TPCC 测试脚本，支持MySQL、Oracle 、EnterpriseDB、PostgreSQL以及SQL Server 等数据库的性能压力测试。模拟多种事务处理：新订单、支付操作、订单状态查询、发货、库存状态查询等，从而获得最终的压测值。
安装及压测大致步骤 总结在linux安装BenchmarkSQL工具，并使用的步骤。压测工具安装的主机是单独的，即不是放在待压测的数据库服务器上，前者通过jdbc连接到后者进行压测。
将BenchmarkSQL安装包传到主机上，并解压 额外需要安装ant和jdk 使用ant编译BenchmarkSQL 在待压测数据库中，创建压测用户 修改BenchmarkSQL配置文件props.xxx，将连接驱动、地址、用户配置正确。并设置所需的压测参数 执行压测数据导入命令 sh runDatabaseBuild.sh props.xxx 执行正式压测命令 ./runBenchmark.sh props.xxx。运行后可以看到实时的tpmC数值，运行结束后会显示平均的tpmC数值。 压测结果生成 执行删除压测数据命令 ./runDatabaseDestroy.sh props.xxx props配置文件解析 可参考：
https://blog.csdn.net/weixin_47308871/article/details/123872130
http://t.zoukankan.com/DFX339-p-13071848.html
https://www.cnblogs.com/klb561/p/10513528.html
Warehouses 代表仓库数,框中的数字表示该表将存放的记录条数，仓库数的调整在测试中能够体现数据库所能支持的数据规模的能力。每个 Warehouse 的数据量，其大小约为 76823.04KB，可以有小量的变化，因为测试过程中将会插入或删除现有记录。可以根据每个Warehouse的数据量，计算测试过程中的数据总量。计算公式为：数据总量（KB）≈ Warehouse个数*76823.04KB以10个Warehouse的数据量为例计算其数据总量大小约为：768230.4KBloadWorkers=10 //用于在数据库中初始化数据的加载进程数量，默认为4，实际使用过程中可以根据实际情况调整，加载速度会随worker数量的增加而有所提升terminals=10 //终端数，即并发客户端数量，通常设置为CPU线程总数的2～6倍runTxnsPerTerminal=10 //每个终端（terminal）运行的固定事务数量，例如：如果该值设置为10，意味着每个terminal运行10个事务，如果有32个终端，那整体运行320个事务后，测试结束。该参数配置为非0值时，下面的runMins参数必须设置为0runMins=0 //要测试的整体时间，单位为分钟，如果runMins设置为60，那么测试持续1小时候结束。该值设置为非0值时，runTxnsPerTerminal参数必须设置为0。这两个参数不能同时设置为正整数，如果设置其中一个，另一个必须为0，主要区别是runMins定义时间长度来控制测试时间；runTxnsPerTerminal定义事务总数来控制时间。 测试指标 流量指标（Throughput,简称tpmC) 流量指标(Throughput,简称tpmC)：按照TPC组织的定义，流量指标描述了系统在执行支付操作、订单状态查询、发货和库存状态查询这4种交易的同时，每分钟可以处理多少个新订单交易。所有交易的响应时间必须满 足TPC-C测试规范的要求，且各种交易数量所占的比例也应该满足TPC-C测试规范的要求。在这种情况下，流量指标值越大说明系统的联机事务处理能力越高。
性价比（Price/Performance,简称Price/tpmC)。 性价比（Price/Performance,简称Price/tpmc)：即测试系统的整体价格与流量指标的比值，在获得相同的tpmC值的情况下，价格越低越好。
参考链接 https://zhuanlan.zhihu.com/p/396651167
https://www.modb.pro/db/137349
https://blog.csdn.net/ActionTech/article/details/123985424
https://www.cnblogs.com/klb561/p/10513528.html
https://wade-test.readthedocs.io/zh/latest/BenchmarkSQL5.0%20%E6%95%B0%E6%8D%AE%E5%BA%93%20TPC-C%20%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%20-%20%E7%91%BE%E7%86%99%E7%9A%84%E5%8D%9A%E5%AE%A2%20JL%20Blog/</description>
    </item>
    
    <item>
      <title>数据库测试扫盲篇</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%89%AB%E7%9B%B2%E7%AF%87/</link>
      <pubDate>Wed, 31 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%89%AB%E7%9B%B2%E7%AF%87/</guid>
      <description>数据库测试扫盲篇 最近参与数据库POC测试，鉴于对数据库还不够了解，决定先以一些测试案例为蓝本，自我扫盲下。
表空间以及表空间管理 1、什么是表空间（TABLESPACE）
表空间是一种存储结构，它包含表、索引、大对象和长型数据。
以ORACLE为例，一个ORACLE数据库能够有一个或多个表空间，而一个表空间则对应着一个或多个物理的数据库文件，但一个数据库文件只能与一个表空间相联系。表空间是ORACLE数据库恢复的最小单位，容纳着许多数据库实体，如表、视图、索引、聚簇、回退段和临时段等。
2、什么是表空间管理
表空间管理包括：如对表空间的创建、修改、删除、扩容
参考链接
https://www.ibm.com/docs/zh/db2/10.5?topic=databases-table-spaces
https://www.modb.pro/db/335060
https://www.cnblogs.com/kerrycode/p/3418694.html
https://blog.51cto.com/u_14056283/3076029
数据库对象 一个数据库对象是 数据库中用于存储或引用数据的任何已定义对象。我们从 create 命令所做的任何事情都称为数据库对象。它可以用来保存和操作数据。
主要的数据库对象包含：触发器（Trigger）、表（Table）、视图（View）、存储过程（StoredProcedure）、索引（Index）、缺省值（Default）、图表（Diagram）、用户（User）、规则（Rule）等几类
参考链接
https://www.jianshu.com/p/ec63e6937e7c
https://zh-cn.myubi.tv/21731-what-is-a-database-object
数据库约束 概念：数据库约束是防止非法记录的规则，约束保存在数据字典(data dictionary)中， 约束可以被定义在列级或者表级。
类型：总的来说有五种：唯一性和主键约束、外键约束、检查约束、空值约束、默认值约束。
有五大关键词，UNIQUE和Primary Key, Foreign Key, CHECK, NOT NULL, DEFAULT
参考链接
https://developer.aliyun.com/article/91298
https://www.cnblogs.com/netsql/archive/2010/05/06/1729162.html
视图 视图是从一个或几个基本表（或视图）导出的表。 它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。 所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。 视图只供查询，数据不可更改。
参考链接
https://zhuanlan.zhihu.com/p/372569011
触发器(trigger) 触发器是与表有关的数据库对象，指的是在insert\update\delete操作之前或者之后，能够触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以使得应用在数据库端确保数据的完整性以及日志记录，数据校验等操作。并且可以使用OLD和NEW来引用触发器中发生变化的记录内容。
触发器的分类：
DML触发器：DML（Data Manipulation Language）触发器是当数据库服务器中发生数据操作语言事件时执行的存储过程。DML触发器又分为两类：After触发器和Instead Of触发器
DDL触发器：DDL触发器是在响应数据定义语言（Data Definition Language）事件时执行的存储过程。DDL触发器一般用于执行数据库中管理任务。如审核和规范数据库操作、防止数据库表结构被修改等。
例如：
create trigger trigger_name before/after insert/update/delete on table_name [for each row] --- 行级触发器 begin trigger_stmt; end; 参考链接</description>
    </item>
    
    <item>
      <title>Linux-安装Oracle</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/linux-%E5%AE%89%E8%A3%85oracle/</link>
      <pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/linux-%E5%AE%89%E8%A3%85oracle/</guid>
      <description>Linux-安装Oracle数据库 安装【失败】，可能因为我的服务器空间不足。。。罢了，先放着吧
背景：我的阿里云linux服务器（CentOS 7.8 64位）之前在宝塔已懒人安装了mysql，现需要在服务器上学习Oracle，所以先记录安装过程（静默安装）。
正式安装之前，可以先检测下是否已有安装Oracle程序。若已有安装oracle，应能看到oracle进程，且一般都会有oracle用户。我在本机上验证如下，是没有安装过的，
[cindy@iZbp15qc4wmx335c268l5mZ ~]$ ps -ef | grep oracle cindy 26709 26624 0 20:22 pts/0 00:00:00 grep --color=auto oracle [cindy@iZbp15qc4wmx335c268l5mZ ~]$ id oracle id: oracle: no such user [cindy@iZbp15qc4wmx335c268l5mZ ~]$ rpm -qa | grep oracle # 查看以rpm包安装的软件列表 [cindy@iZbp15qc4wmx335c268l5mZ ~]$ yum list installed | grep oracle # 查看以yum安装的软件列表 步骤概览 参考 http://www.javashuo.com/article/p-sbcnrnqx-gr.html
安装swap分区 安装oracle依赖包 建立用户/用户组 在外面下载oralce包并传到linux oracle安装 安装swap分区 oracle安装需要swap分区，所以先检查下是否已有swap分区。
[root@iZbp15qc4wmx335c268l5mZ ~]# free total used free shared buff/cache available Mem: 964136 425288 172940 304 365908 366360 Swap: 1049596 303616 745980 [root@iZbp15qc4wmx335c268l5mZ ~]# cat /etc/fstab # # /etc/fstab # Created by anaconda on Mon Sep 14 07:14:22 2020 # # Accessible filesystems, by reference, are maintained under &amp;#39;/dev/disk&amp;#39; # See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info # UUID=9f2d3e15-a78a-4f3d-8385-0165b4b67864 / ext4 defaults 1 1 /www/swap swap swap defaults 0 0 看起来是已有的，如果没有，可参考链接的方式创建。</description>
    </item>
    
    <item>
      <title>Oracle-实现事务提交和回滚</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/oracle-%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%92%8C%E5%9B%9E%E6%BB%9A/</link>
      <pubDate>Tue, 02 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/oracle-%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%92%8C%E5%9B%9E%E6%BB%9A/</guid>
      <description>Oracle-实现事务提交和回滚 背景：一直以来用sqlplus /执行多条sql时，某条sql失败后无法回滚前面的sql，并会继续执行下面的sql。即，如果 sqlplus 中遇到了一个 sql 或者 pl/ssql 错误, 一般会报告这个错误然后继续处理。在交互模式下, 这种处理是很理想的, 但是如果运行的是一个脚本,我们一般不希望失败了还继续执行 。这可太不科学了！经过高人指点，可以用一条命令来实现失败回滚功能。故在此学习和记录下。
失败回滚命令 WHENEVER SQLERROR官网介绍： https://docs.oracle.com/en/database/oracle/oracle-database/19/sqpug/WHENEVER-SQLERROR.html#GUID-66C1C12C-5E95-4440-A37B-7CCE7E33491C
常见用法 WHENEVER SQLERROR {EXIT [SUCCESS | FAILURE | WARNING | n | variable | :BindVariable] [COMMIT | ROLLBACK] | CONTINUE [COMMIT | ROLLBACK | NONE]} 出现错误后退出sql执行 SQL&amp;gt; WHENEVER SQLERROR EXIT SQL.SQLCODE 出现错误后先回滚【还没提交的变化】再退出sql执行 SQL&amp;gt; WHENEVER SQLERROR EXIT SQL.SQLCODE ROLLBACK ---回滚退出，并返回错误码SQL.SQLCODE or SQL&amp;gt; WHENEVER SQLERROR SQL.SQLCODE EXIT ROLLBACK 失败不回滚命令 如果要实现失败不回滚（当发生错误时，对之前执行的语句进行提交，并保留SQL*Plus）：
参考 https://juejin.cn/post/7075307770173456392
whenever sqlerror continue commit spool命令 此外，可以先认识下spool命令。</description>
    </item>
    
    <item>
      <title>ORACLE-存储过程</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/oracle-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/oracle-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>ORACLE-存储过程 概念 存储过程(Stored Procedure)：
一组为了完成某功能的一段sql语句集（一种PL/SQL块），存储在数据库中，经过第一次编译后再次调用就无需再次编译，用户通过调用指定存储过程名称和给定参数来调用。当数据库启动时,会自动加载到数据库内存中,执行效率高。
当对数据库进行复杂操作时(如对多个表进行Update、Insert、Query、Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。
函数和存储过程的区别 https://www.php.cn/oracle/489142.html#/
存储过程 函数 用于在数据库中完成特定的操作或任务（如插入、删除等） 用于特定数据（如查询返回值） 程序头部声明用PROCEDURE 程序头部声明用FUNCTION 程序头部声明时不需要返回类型 程序头部声明时要描述返回类型，而且PL/SQL块至少要包括一个有效的RETURN语句 可以使用IN/OUT/IN OUT3种参数模式 可以使用IN/OUT/IN OUT3种参数模式 可以作为独立的PL/SQL语句执行 不能独立执行，必须作为表达式的一部分调用 可以通过OUT/IN OUT返回零个或多个值 对过RETURN语句返回一个值，且该值与声明部分一致，也可以通过OUT类型的参数带出变量 SQL语句（DML或SELECT）中不可以调用存储过程 SQL语句（DML或SELECT）中可以调用函数 优点 更快（无需再次编译） 模块性 可维护性高 节省网络传输（存储在数据库中） 更安全（存储过程控制执行权限） 存储过程创建语法 CREATE [OR REPLACE] PROCEDURE pro_name [(p1 in|out 数据格式, p2 in|out 数据格式, ...)] is|as 声明部分 begin plsql代码块 exception 异常处理部分 end; 注意：
OR REPLACE表示的是若已存在同名存储过程，则替换原内容
形参定义中：
参数不区分大小写，不需要DECLARE关键字
其中参数IN表示输入参数，是参数的默认模式。入参值无法被修改。 OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。 OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程 IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。
声明部分：用于存储过程使用到的变量声明 https://www.cnblogs.com/caiguangbi-53/p/11398696.html#/
声明的三种方法
直接声明数据类型，如p1 varchar2(60)或p2 number(2) 沿用数据表中某数据字段类型%TYPE，如p1 table1.</description>
    </item>
    
    <item>
      <title>ORACLE-序列</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/oracle-%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/oracle-%E5%BA%8F%E5%88%97/</guid>
      <description>ORACLE-序列 背景：了解NEXTVAL的概念
ORACLE序列 概念 是oacle提供的用于产生一系列唯一数字的数据库对象。主要用于提供主键值。
sequence是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。**其主要的用途是生成表的主键值，可以在插入语句中引用，在插入之前，获取序列号nextval值，然后进行插入。**也可以通过查询检查当前值，或使序列增至下一个值。（https://www.jb51.net/article/220007.htm#/）
创建方式 CREATE SEQUENCE sequence //创建序列名称 [INCREMENT BY n] //递增的序列值是n 如果n是正数就递增,如果是负数就递减 默认是1 [START WITH n] //开始的值,递增默认是minvalue 递减是maxvalue [{MAXVALUE n | NOMAXVALUE}] //最大值 [{MINVALUE n | NOMINVALUE}] //最小值 [{CYCLE | NOCYCLE}] //循环/不循环 [{CACHE n | NOCACHE}];//分配并存入到内存中 CURRVAL CURRVAL 中存放序列的当前值
SELECT INR_REQUIRMENT_SQUENCE.CURRVAL FROM dual - 获取当前的sequence的值
CURRVAL = 最后一次对 NEXTVAL 的引用所返回的值
NEXTVAL NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用
select SEQ_TABLESPACETEST_con.nextval from dual - 获取下一个值，序列经过查询每次也会自增
注意：
第一次访问序列时，需要先引用 sequence.NEXTVAL获取初始值。第一次在没有访问NEXTVAL前，是没有CURRVAL的。 后面每次引用 NEXTVAL，用已定义的 step 添加序列值并返回序列新的添加以后的值。 一个sql语句中只能生成一次nextval，就算调用多次，获取的也只有一个nextval nextval添加完的序列值不能取消，也就是说就算后面回滚当前事务，也不会还原。故：某些序列数可能被跳过 假设 sequence.</description>
    </item>
    
    <item>
      <title>SQL函数篇</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/sql%E5%87%BD%E6%95%B0%E7%AF%87/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/sql%E5%87%BD%E6%95%B0%E7%AF%87/</guid>
      <description>SQL函数篇 lpad/rpad函数 lpad/rpad函数 此为Oracle函数。l/r(left/right)+pad(填充)，表示从左边/右边填充。
格式：lpad( string, padded_length, [ pad_string ] ) （rpad同理）
参数一：被填充/截取的原字符串
参数二：最终长度
参数三：填充的字符，若无赋值，则默认填充空格
注意：若原字符串长度大于参数二的长度，则lpad从左开始截取指定长度（rpad从右边）
SQL&amp;gt; select lpad(&amp;#39;abcde&amp;#39;,10,&amp;#39;x&amp;#39;) from dual; LPAD(&amp;#39;ABCDE&amp;#39;,10,&amp;#39;X&amp;#39;) -------------------- xxxxxabcde SQL&amp;gt; select lpad(&amp;#39;abcde&amp;#39;,2) from dual; LPAD(&amp;#39;ABCDE&amp;#39;,2) --------------- ab 参考链接：https://blog.csdn.net/yulei_qq/article/details/17389901#/</description>
    </item>
    
    <item>
      <title>数据库无效对象</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%95%88%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 14 May 2022 22:51:46 +0800</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%95%88%E5%AF%B9%E8%B1%A1/</guid>
      <description>数据库无效对象 背景：报“ORACLE存在无效对象，可能影响应用性能，评估是否重建对象”
概念 无效：INVALID 对象：视图、物化视图、函数、包、触发器等 无效 PL/SQL 对象和不可用索引会对性能产生影响。无效 PL/SQL 对象必须先进行重编译，然后才能使用。这需要在执行尝试访问 PL/SQL 程序包、过程或函数的第一个操作之前花费一段编译时间。如果 PL/SQL 重编译未成功，，则操作会因发生错误而失败。优化程序会忽略不可用索引。如果 SQL 语句性能的好坏取决于已标记为不可用的索引，则只有重建索引才能改善性能。
如果查找到 INVALID 状态的 PL/SQL 对象，需要回答的第一个问题是“此对象曾经是 VALID 的吗？”应用程序开发人员常常会忘记清除不起作用的代码。如果 PL/SQL 对象因代码错误而无效，则除了纠正该错误之外，没有什么别的方法。如果该过程在过去曾经有效，最近才变为无效，则可选择以下两种方法解决这个问题：
1.不做任何处理。如果需要，大多数 PL/SQL 对象在调用时会自动重新编译。用户在对象重新编译时会经历短暂的延迟。（大多数情况下，这种延迟不十分明显。）
2.手动重新编译无效对象。
无效对象产生的原因 当被引用对象的结构变更时，都会使得相关的依赖对象转变为INVALID状态
如视图A来源于表B，当表B的结构改变时，会导致视图A变成无效对象。但当再一次调用视图A时，会自动编译视图A，使其再次变为有效。
发布SQL脚本时（包、存储过程、函数等），没有充分测试，编译时出错，这时对象变为无效。
数据库升级、迁移时，出现大量无效对象(本质原因，臆测归结为原因1)
诸如此类各种情况：例如，Oracle 会自动维护分区索引，对于全局索引，如果在对分区表操作时，没有指定update index，则会导致全局索引失效，需要重建。
查找无效对象 统计失效对象 执行用户：SYSTEM用户或其他有权限的用户
SQL&amp;gt; select owner, object_name, object_type from dba_objects t where status = &amp;#39;INVALID&amp;#39; order by t.owner,t.object_type; 或者
select owner, object_type, status, count(*) from dba_objects where status=&amp;#39;INVALID&amp;#39; group by owner, object_type, status order by owner, object_type 查看具体失效对象 col owner for a20; col object_name for a32; col object_type for a16 col status for a8 select owner, object_name, object_type, status from dba_objects where status=&amp;#39;INVALID&amp;#39; order by 1,2,3; 解决 重新编译失效的对象（以下步骤参考：https://developer.</description>
    </item>
    
    <item>
      <title>部分sql的user_io_wait_time值较大</title>
      <link>https://huangxindi.com/post/workspace/01-tech/database/%E9%83%A8%E5%88%86sql%E7%9A%84user_io_wait_time%E5%80%BC%E8%BE%83%E5%A4%A7/</link>
      <pubDate>Sat, 14 May 2022 22:51:46 +0800</pubDate>
      
      <guid>https://huangxindi.com/post/workspace/01-tech/database/%E9%83%A8%E5%88%86sql%E7%9A%84user_io_wait_time%E5%80%BC%E8%BE%83%E5%A4%A7/</guid>
      <description>部分sql的user_io_wait_time值较大 背景：报“针对近一个月的sql语句执行进行分析，每天执行较频繁的sql中，有几个sql的user_io_wait_time值较大，建议进行优化
oracle sql 响应时间分析 1、按照IO等待取top5（https://blog.csdn.net/fengsd_sy/article/details/51322766#/）
select * from (select sql_text, sql_id, elapsed_time, cpu_time, user_io_wait_time from sys.v_$sqlarea order by 5 desc) where rownum &amp;lt; 6; 2、根据步骤1获取具体SQL详情
select event, time_waited, owner, object_name, current_file#, current_block# from sys.v_$active_session_history a, sys.dba_objects b where sql_id = &amp;#39;6gvch1xu9ca3g&amp;#39; and a.current_obj# = b.object_id and time_waited &amp;lt;&amp;gt; 0; </description>
    </item>
    
  </channel>
</rss>
