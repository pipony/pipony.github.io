<!DOCTYPE html>






























<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-us"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>软考-中级软件设计师-06 数据结构与算法基础 - </title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="06 数据结构与算法基础 数组 考点：存储地址计算
稀疏矩阵 矩阵坐标转换到数组坐标的解题技巧：带入特殊值
数据结构的定义 概念：计算机存储和组织数据的方式
逻辑结构划分
线性结构 非线性结构 树 图 线性表 分类
顺序表（一维数组形式）
链表（节点包含数据与指针）
单链表 循环链表 双向链表 队列（先进先出）
循环队列
栈（先进后出）
链表的基本操作（删除和插入节点）
顺序存储和链式存储对比：
广义表 概念：线性表的推广，以递归的方式进行定义
广度（最外层括号包含的元素个数）、深度（包含括号的重数）
表头head（最外括号的第一个元素）、表尾tail（除去表头的其他所有部分）
树与二叉树 结点的度：孩子数
数的度：所有结点度数最高的度
内部节点：非头节点和叶子节点
深度：最大的层数
特殊二叉树 满二叉树 完全二叉树（除最后一层，上面层都满；且最后一层从左到右没有中间缺失的情况） 二叉树遍历 前、中、后序遍历：差别在根节点前、中、后时候被访问
层次遍历
反向构造二叉树 例题：
树转二叉树 原则：
孩子结点 -&gt; 左子树结点 兄弟结点 -&gt; 右孩子结点 除了挨个用【原则】分析，还可以用连线法：如上图的虚线图所示。将兄弟结点连起来，并将第一个孩子以外的孩子结点的连线去掉，然后旋转，得到最终的二叉树
查找二叉树（二叉排序树） 特点：
左孩子小于根 右孩子大于根 极大提高查找速度 操作：插入和删除结点
最优二叉树（哈夫曼树） 哈夫曼树：用于无损压缩
基本概念：
树的路径长度 权（每个结点的数值，一般表示出现的频度） 带权路径长度 树的带权路径长度（树的代价） 构造哈夫曼树：即构造带权路径长度最小的树
例题：
求解树的带权路径长度：将所有叶子结点的带权路径长度相加
线索二叉树 why：很多结点的左右指针是空的，可以利用这些空闲指针，来方便遍历
前序线索二叉树 中序线索二叉树 后序线索二叉树 构造线索二叉树：左右线索指针指向的是x序排列的前/后面的结点" />
  <meta
    name="author"
    content="Cindy.H"
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://huangxindi.com/main.min.css" />

  

  
     
  <link rel="preload" as="image" href="https://huangxindi.com/theme.png" />

  
  
  
  

  
  <link rel="preload" as="image" href="https://huangxindi.com/github.svg" />
  
  <link rel="preload" as="image" href="https://huangxindi.com/rss.svg" />
  

  
  <link rel="icon" href="https://huangxindi.com/favicon.ico" />
  <link rel="apple-touch-icon" href="https://huangxindi.com/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.101.0" />

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="软考-中级软件设计师-06 数据结构与算法基础" />
<meta property="og:description" content="06 数据结构与算法基础 数组 考点：存储地址计算
稀疏矩阵 矩阵坐标转换到数组坐标的解题技巧：带入特殊值
数据结构的定义 概念：计算机存储和组织数据的方式
逻辑结构划分
线性结构 非线性结构 树 图 线性表 分类
顺序表（一维数组形式）
链表（节点包含数据与指针）
单链表 循环链表 双向链表 队列（先进先出）
循环队列
栈（先进后出）
链表的基本操作（删除和插入节点）
顺序存储和链式存储对比：
广义表 概念：线性表的推广，以递归的方式进行定义
广度（最外层括号包含的元素个数）、深度（包含括号的重数）
表头head（最外括号的第一个元素）、表尾tail（除去表头的其他所有部分）
树与二叉树 结点的度：孩子数
数的度：所有结点度数最高的度
内部节点：非头节点和叶子节点
深度：最大的层数
特殊二叉树 满二叉树 完全二叉树（除最后一层，上面层都满；且最后一层从左到右没有中间缺失的情况） 二叉树遍历 前、中、后序遍历：差别在根节点前、中、后时候被访问
层次遍历
反向构造二叉树 例题：
树转二叉树 原则：
孩子结点 -&gt; 左子树结点 兄弟结点 -&gt; 右孩子结点 除了挨个用【原则】分析，还可以用连线法：如上图的虚线图所示。将兄弟结点连起来，并将第一个孩子以外的孩子结点的连线去掉，然后旋转，得到最终的二叉树
查找二叉树（二叉排序树） 特点：
左孩子小于根 右孩子大于根 极大提高查找速度 操作：插入和删除结点
最优二叉树（哈夫曼树） 哈夫曼树：用于无损压缩
基本概念：
树的路径长度 权（每个结点的数值，一般表示出现的频度） 带权路径长度 树的带权路径长度（树的代价） 构造哈夫曼树：即构造带权路径长度最小的树
例题：
求解树的带权路径长度：将所有叶子结点的带权路径长度相加
线索二叉树 why：很多结点的左右指针是空的，可以利用这些空闲指针，来方便遍历
前序线索二叉树 中序线索二叉树 后序线索二叉树 构造线索二叉树：左右线索指针指向的是x序排列的前/后面的结点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://huangxindi.com/post/workspace/01-tech/software-designer/06-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-14T22:51:46+08:00" />
<meta property="article:modified_time" content="2022-05-14T22:51:46+08:00" />


  
  <meta itemprop="name" content="软考-中级软件设计师-06 数据结构与算法基础">
<meta itemprop="description" content="06 数据结构与算法基础 数组 考点：存储地址计算
稀疏矩阵 矩阵坐标转换到数组坐标的解题技巧：带入特殊值
数据结构的定义 概念：计算机存储和组织数据的方式
逻辑结构划分
线性结构 非线性结构 树 图 线性表 分类
顺序表（一维数组形式）
链表（节点包含数据与指针）
单链表 循环链表 双向链表 队列（先进先出）
循环队列
栈（先进后出）
链表的基本操作（删除和插入节点）
顺序存储和链式存储对比：
广义表 概念：线性表的推广，以递归的方式进行定义
广度（最外层括号包含的元素个数）、深度（包含括号的重数）
表头head（最外括号的第一个元素）、表尾tail（除去表头的其他所有部分）
树与二叉树 结点的度：孩子数
数的度：所有结点度数最高的度
内部节点：非头节点和叶子节点
深度：最大的层数
特殊二叉树 满二叉树 完全二叉树（除最后一层，上面层都满；且最后一层从左到右没有中间缺失的情况） 二叉树遍历 前、中、后序遍历：差别在根节点前、中、后时候被访问
层次遍历
反向构造二叉树 例题：
树转二叉树 原则：
孩子结点 -&gt; 左子树结点 兄弟结点 -&gt; 右孩子结点 除了挨个用【原则】分析，还可以用连线法：如上图的虚线图所示。将兄弟结点连起来，并将第一个孩子以外的孩子结点的连线去掉，然后旋转，得到最终的二叉树
查找二叉树（二叉排序树） 特点：
左孩子小于根 右孩子大于根 极大提高查找速度 操作：插入和删除结点
最优二叉树（哈夫曼树） 哈夫曼树：用于无损压缩
基本概念：
树的路径长度 权（每个结点的数值，一般表示出现的频度） 带权路径长度 树的带权路径长度（树的代价） 构造哈夫曼树：即构造带权路径长度最小的树
例题：
求解树的带权路径长度：将所有叶子结点的带权路径长度相加
线索二叉树 why：很多结点的左右指针是空的，可以利用这些空闲指针，来方便遍历
前序线索二叉树 中序线索二叉树 后序线索二叉树 构造线索二叉树：左右线索指针指向的是x序排列的前/后面的结点"><meta itemprop="datePublished" content="2022-05-14T22:51:46+08:00" />
<meta itemprop="dateModified" content="2022-05-14T22:51:46+08:00" />
<meta itemprop="wordCount" content="144">
<meta itemprop="keywords" content="软考-中级软件设计师," />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="软考-中级软件设计师-06 数据结构与算法基础"/>
<meta name="twitter:description" content="06 数据结构与算法基础 数组 考点：存储地址计算
稀疏矩阵 矩阵坐标转换到数组坐标的解题技巧：带入特殊值
数据结构的定义 概念：计算机存储和组织数据的方式
逻辑结构划分
线性结构 非线性结构 树 图 线性表 分类
顺序表（一维数组形式）
链表（节点包含数据与指针）
单链表 循环链表 双向链表 队列（先进先出）
循环队列
栈（先进后出）
链表的基本操作（删除和插入节点）
顺序存储和链式存储对比：
广义表 概念：线性表的推广，以递归的方式进行定义
广度（最外层括号包含的元素个数）、深度（包含括号的重数）
表头head（最外括号的第一个元素）、表尾tail（除去表头的其他所有部分）
树与二叉树 结点的度：孩子数
数的度：所有结点度数最高的度
内部节点：非头节点和叶子节点
深度：最大的层数
特殊二叉树 满二叉树 完全二叉树（除最后一层，上面层都满；且最后一层从左到右没有中间缺失的情况） 二叉树遍历 前、中、后序遍历：差别在根节点前、中、后时候被访问
层次遍历
反向构造二叉树 例题：
树转二叉树 原则：
孩子结点 -&gt; 左子树结点 兄弟结点 -&gt; 右孩子结点 除了挨个用【原则】分析，还可以用连线法：如上图的虚线图所示。将兄弟结点连起来，并将第一个孩子以外的孩子结点的连线去掉，然后旋转，得到最终的二叉树
查找二叉树（二叉排序树） 特点：
左孩子小于根 右孩子大于根 极大提高查找速度 操作：插入和删除结点
最优二叉树（哈夫曼树） 哈夫曼树：用于无损压缩
基本概念：
树的路径长度 权（每个结点的数值，一般表示出现的频度） 带权路径长度 树的带权路径长度（树的代价） 构造哈夫曼树：即构造带权路径长度最小的树
例题：
求解树的带权路径长度：将所有叶子结点的带权路径长度相加
线索二叉树 why：很多结点的左右指针是空的，可以利用这些空闲指针，来方便遍历
前序线索二叉树 中序线索二叉树 后序线索二叉树 构造线索二叉树：左右线索指针指向的是x序排列的前/后面的结点"/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold"
      href="https://huangxindi.com/"
      ></a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    
    <nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6">
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/"
        >Home</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/post"
        >Archives</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href=""
        >Tags</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/categories"
        >Categories</a
      >
      
      <a
        class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal"
        href="/post/about"
        >About</a
      >
      
    </nav>
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/https://github.com/pipony"
        target="_blank"
        rel="me"
      ></a>
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./rss.svg)"
        href="https://huangxindi.com/index.xml"
        target="_blank"
        
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">软考-中级软件设计师-06 数据结构与算法基础</h1>

    
    <div class="text-sm opacity-60">
      
      <time>May 14, 2022</time>
      
      
      <span class="mx-1">&middot;</span>
      <span>Cindy.H</span>
      
    </div>
    
  </header>

  <section><h1 id="06-数据结构与算法基础">06 数据结构与算法基础</h1>
<p><img src="http://cdn.huangxindi.com/img/image-20220503153056928.png" alt="image-20220503153056928"></p>
<h2 id="数组">数组</h2>
<p>考点：存储地址计算</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503153232866.png" alt="image-20220503153232866"></p>
<h2 id="稀疏矩阵">稀疏矩阵</h2>
<p><img src="http://cdn.huangxindi.com/img/image-20220503153602838.png" alt="image-20220503153602838"></p>
<p>矩阵坐标转换到数组坐标的解题技巧：带入特殊值</p>
<h2 id="数据结构的定义">数据结构的定义</h2>
<p>概念：计算机存储和组织数据的方式</p>
<p>逻辑结构划分</p>
<ul>
<li>线性结构</li>
<li>非线性结构
<ul>
<li>树</li>
<li>图</li>
</ul>
</li>
</ul>
<h2 id="线性表">线性表</h2>
<p>分类</p>
<ul>
<li>
<p>顺序表（一维数组形式）</p>
</li>
<li>
<p>链表（节点包含数据与指针）</p>
<ul>
<li>单链表</li>
<li>循环链表</li>
<li>双向链表</li>
</ul>
</li>
<li>
<p>队列（先进先出）</p>
<ul>
<li>
<p>循环队列</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503155120397.png" alt="image-20220503155120397"></p>
</li>
</ul>
</li>
<li>
<p>栈（先进后出）</p>
</li>
</ul>
<p>链表的基本操作（删除和插入节点）</p>
<p>顺序存储和链式存储对比：</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503154523426.png" alt="image-20220503154523426"></p>
<h2 id="广义表">广义表</h2>
<p>概念：线性表的推广，以递归的方式进行定义</p>
<p>广度（最外层括号包含的元素个数）、深度（包含括号的重数）</p>
<p>表头head（最外括号的第一个元素）、表尾tail（除去表头的其他所有部分）</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503160909846.png" alt="image-20220503160909846"></p>
<h2 id="树与二叉树">树与二叉树</h2>
<p><img src="http://cdn.huangxindi.com/img/image-20220503160933287.png" alt="image-20220503160933287"></p>
<p>结点的度：孩子数</p>
<p>数的度：所有结点度数最高的度</p>
<p>内部节点：非头节点和叶子节点</p>
<p>深度：最大的层数</p>
<h3 id="特殊二叉树">特殊二叉树</h3>
<ul>
<li>满二叉树</li>
<li>完全二叉树（除最后一层，上面层都满；且最后一层从左到右没有<strong>中间缺失</strong>的情况）</li>
</ul>
<p><img src="http://cdn.huangxindi.com/img/image-20220503161436409.png" alt="image-20220503161436409"></p>
<h3 id="二叉树遍历">二叉树遍历</h3>
<ul>
<li>
<p>前、中、后序遍历：差别在根节点前、中、后时候被访问</p>
</li>
<li>
<p>层次遍历</p>
</li>
</ul>
<h3 id="反向构造二叉树">反向构造二叉树</h3>
<p>例题：</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503162440549.png" alt="image-20220503162440549"></p>
<h3 id="树转二叉树">树转二叉树</h3>
<p>原则：</p>
<ul>
<li>孩子结点 -&gt; 左子树结点</li>
<li>兄弟结点 -&gt; 右孩子结点</li>
</ul>
<p><img src="http://cdn.huangxindi.com/img/image-20220503162707664.png" alt="image-20220503162707664"></p>
<p>除了挨个用【原则】分析，还可以用连线法：如上图的虚线图所示。将兄弟结点连起来，并将第一个孩子以外的孩子结点的连线去掉，然后旋转，得到最终的二叉树</p>
<h3 id="查找二叉树二叉排序树">查找二叉树（二叉排序树）</h3>
<p>特点：</p>
<ul>
<li>左孩子小于根</li>
<li>右孩子大于根</li>
<li>极大提高查找速度</li>
</ul>
<p>操作：插入和删除结点</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503163239625.png" alt="image-20220503163239625"></p>
<h3 id="最优二叉树哈夫曼树">最优二叉树（哈夫曼树）</h3>
<p>哈夫曼树：用于无损压缩</p>
<p>基本概念：</p>
<ul>
<li>树的路径长度</li>
<li>权（每个结点的数值，一般表示出现的频度）</li>
<li>带权路径长度</li>
<li>树的带权路径长度（树的代价）</li>
</ul>
<p>构造哈夫曼树：<strong>即构造带权路径长度最小的树</strong></p>
<p>例题：</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503163738267.png" alt="image-20220503163738267"></p>
<p>求解树的带权路径长度：<strong>将所有叶子结点的带权路径长度相加</strong></p>
<h2 id="线索二叉树">线索二叉树</h2>
<p>why：很多结点的左右指针是空的，可以利用这些空闲指针，来方便遍历</p>
<ul>
<li>前序线索二叉树</li>
<li>中序线索二叉树</li>
<li>后序线索二叉树</li>
</ul>
<p>构造线索二叉树：左右线索指针指向的是x序排列的前/后面的结点</p>
<h2 id="平衡二叉树">平衡二叉树</h2>
<p>定义：</p>
<ul>
<li>左右子树深度相差不超过1</li>
<li>每个结点的平衡度（左子树深度-右子树深度）只能为-1，0，1</li>
</ul>
<p>非平衡二叉树 -&gt; 平衡二叉树</p>
<h2 id="图">图</h2>
<p>图与树最大的区别：<strong>树没有环路</strong></p>
<p>分类：</p>
<ul>
<li>有向图</li>
<li>无向图</li>
<li>完全图（可连的边都连了）</li>
</ul>
<h3 id="存储">存储</h3>
<ul>
<li>邻接矩阵</li>
</ul>
<p><img src="http://cdn.huangxindi.com/img/image-20220503165639983.png" alt="image-20220503165639983"></p>
<ul>
<li>邻接表</li>
</ul>
<p><img src="http://cdn.huangxindi.com/img/image-20220503165817778.png" alt="image-20220503165817778"></p>
<h3 id="图的遍历">图的遍历</h3>
<ul>
<li>深度遍历</li>
<li>广度遍历</li>
</ul>
<p>根据邻接表进行遍历：广度是一个结点所连的线走到底，深度是连续试探第一个</p>
<h3 id="拓扑排序">拓扑排序</h3>
<p>表示活动之间开始的<strong>先后关系</strong></p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503170224108.png" alt="image-20220503170224108"></p>
<p>执行完把连线去掉，继续分析</p>
<h3 id="图的最小生成树">图的最小生成树</h3>
<p>使得留下来的边（n-1条，n为节点数）构成树（注意不能有环），权值总和最小</p>
<h4 id="普利姆算法">普利姆算法</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503170607893.png" alt="image-20220503170607893"></p>
<p>分析：画图时实时将结点分成两个阵营，寻找到另一个阵营的最短边</p>
<h4 id="克鲁斯卡尔算法">克鲁斯卡尔算法</h4>
<p>依次选择权最小的边，注意不要构成环。连接所有结点后，即生成结束</p>
<h2 id="算法基础">算法基础</h2>
<h3 id="算法的特性">算法的特性</h3>
<p><img src="http://cdn.huangxindi.com/img/image-20220503170847056.png" alt="image-20220503170847056"></p>
<h3 id="算法的复杂度">算法的复杂度</h3>
<p><img src="http://cdn.huangxindi.com/img/image-20220503171033563.png" alt="image-20220503171033563"></p>
<h3 id="顺序查找和二分查找">顺序查找和二分查找</h3>
<h4 id="顺序查找">顺序查找</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503171742095.png" alt="image-20220503171742095"></p>
<h4 id="二分查找">二分查找</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503171839069.png" alt="image-20220503171839069"></p>
<p>前提：查找内容本身是有序排序的</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503172118001.png" alt="image-20220503172118001"></p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503172151529.png" alt="image-20220503172151529"></p>
<h3 id="散列表">散列表</h3>
<p><img src="http://cdn.huangxindi.com/img/image-20220503172237781.png" alt="image-20220503172237781"></p>
<p>冲突解决：</p>
<ul>
<li>线性探测法（往后顺序查找第一个空的）</li>
<li>伪随机数法</li>
<li>再散列法</li>
</ul>
<h3 id="排序重要">排序（重要）</h3>
<p><img src="http://cdn.huangxindi.com/img/image-20220503172611622.png" alt="image-20220503172611622"></p>
<p>稳定性：<strong>值相同的数</strong>，排序后，顺序是否不变</p>
<p>内/外排序：前者只在内存中，后者用到外存</p>
<h4 id="直接插入排序">直接插入排序</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503173036376.png" alt="image-20220503173036376"></p>
<h4 id="希尔排序">希尔排序</h4>
<p>是直接插入排序的一种，但更复杂。</p>
<p>好处是：经过前几轮的组内直接插入排序，序列已基本有序。到最后一轮的全组直接插入排序时，调整顺序的次数会更少。</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503173355864.png" alt="image-20220503173355864"></p>
<h4 id="直接选择排序">直接选择排序</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503173454649.png" alt="image-20220503173454649"></p>
<h4 id="堆排序">堆排序</h4>
<p>堆的概念</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503173755500.png" alt="image-20220503173755500"></p>
<p>堆排列概念和步骤：</p>
<p><img src="http://cdn.huangxindi.com/img/image-20220503173843849.png" alt="image-20220503173843849"></p>
<p><strong>初建堆过程：</strong></p>
<ul>
<li>顺次将结点数组构成完全二叉树</li>
<li>调整为堆（从最后一个非叶子结点开始，而后分析最后第二个）</li>
<li>注意，有的结点调整需要向下继续调整</li>
</ul>
<p><img src="http://cdn.huangxindi.com/img/image-20220503174316966.png" alt="image-20220503174316966"></p>
<p><strong>重新建堆过程：</strong></p>
<ul>
<li>把根结点取走</li>
<li>把堆的最后一个结点放到根结点</li>
<li>从根节点开始与子节点对比，一直往下</li>
</ul>
<p><img src="http://cdn.huangxindi.com/img/image-20220503174646194.png" alt="image-20220503174646194"></p>
<p>所以，诸如从大量数据中求前10小的元素，比较有优势</p>
<h4 id="冒泡排序">冒泡排序</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503175039139.png" alt="image-20220503175039139"></p>
<h4 id="快速排序">快速排序</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503175310879.png" alt="image-20220503175310879"></p>
<p>分析：</p>
<ul>
<li>分治法</li>
<li>与基准比较</li>
</ul>
<h4 id="归并排序">归并排序</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503175501777.png" alt="image-20220503175501777"></p>
<p>一般是两两合并</p>
<h4 id="基数排序">基数排序</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503175728873.png" alt="image-20220503175728873"></p>
<p>基数和关键字的分解有关</p>
<h4 id="排序算法分析常考">排序算法分析（常考）</h4>
<p><img src="http://cdn.huangxindi.com/img/image-20220503175936970.png" alt="image-20220503175936970"></p>
</section>

  
  
  <footer class="mt-12 flex flex-wrap">
     
    <a
      class="mr-1.5 mb-1.5 rounded-lg bg-black/[3%] px-5 py-2 no-underline dark:bg-white/[8%]"
      href="https://huangxindi.com/tags/%E8%BD%AF%E8%80%83-%E4%B8%AD%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88"
      >软考-中级软件设计师</a
    >
    
  </footer>
  

  
  
  
  <nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]">
    
    <a
      class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%]"
      href="https://huangxindi.com/post/workspace/01-tech/software-designer/05-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/"
      ><span class="mr-1.5">←</span><span>软考-中级软件设计师-05 计算机安全</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%]"
      href="https://huangxindi.com/post/workspace/01-tech/software-designer/07-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"
      ><span>软考-中级软件设计师-07 程序设计语言与语言处理程序基础</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  

  
  
  <div class="mt-24" id="graphcomment"></div>
  <script type="text/javascript">
    var __semio__params = {
      graphcommentId: 'YOUR_GRAPH_COMMENT_ID',
      behaviour: {
        
      },
      
    };

    function __semio__onload() {
      __semio__gc_graphlogin(__semio__params);
    }

    (function () {
      var gc = document.createElement('script');
      gc.type = 'text/javascript';
      gc.async = true;
      gc.onload = __semio__onload;
      gc.defer = true;
      gc.src =
        'https://integration.graphcomment.com/gc_graphlogin.js?' + Date.now();
      (
        document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]
      ).appendChild(gc);
    })();
  </script>
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="https://huangxindi.com/"></a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
